# Title: Boussinesq flow generated by a heated cylinder
#
# Description:
#
# The classical Boussinesq approximation is applied to solve the flow
# generated by a heated cylinder. 
#
# A source term proportional to a diffusive tracer is added to the
# vertical component of the velocity field.
#
# Adaptivity is used to generate a "sponge" outflow condition on the
# top boundary.
#
# The turbulent plume obtained is illustrated on Figure \ref{tracer}.
#
# The movie is generated using the scripting mode of GfsView.
#
# \begin{figure}[htbp]
# \begin{center}
# \htmladdnormallinkfoot{\includegraphics[width=0.3\hsize]{t.eps}}{t.mpg}
# \end{center}
# \caption{MPEG movie of the tracer field.}
# \label{tracer}
# \end{figure}
#
# Author: St\'ephane Popinet
# Command: gerris2D boussinesq.gfs | gfsview2D | ppmtoy4m -F 24:1 -v 0 | mpeg2enc -v 0 -o t.mpg
# Version: 0.6.4
# Required files: cylinder.gts
# Running time: 60 minutes
# Generated files: t.mpg t.eps
#
2 1 GfsSimulation GfsBox GfsGEdge {} {
  Time { end = 20 }

  # Use an initial refinement of 8 levels around the solid boundary
  RefineSolid 8

  # Insert the solid boundary defined by cylinder.gts
  GtsSurfaceFile cylinder.gts

  # Add a passive tracer called T
  VariableTracer {} T

  # Add diffusion to tracer T
  SourceDiffusion {} T 0.0001
 
  # Add a source term to the vertical velocity component equal to T
  Source {} V T

  # Dirichlet boundary condition for T on the cylinder
  SurfaceBc T Dirichlet 1

  # Adapt the mesh using the vorticity criterion at every timestep
  # down to a maximum level of 8 if y is smaller than 1.25, 3 otherwise.
  # The topmost part of the domain will never have more than
  # 3 levels of refinement and will act as a very efficient "sponge"
  # layer to damp any eddies before they exit the domain.
  AdaptVorticity { istep = 1 } { maxlevel = (y > 1.25 ? 3 : 8) cmax = 1e-2 }

  # Also adapt according to the tracer gradient
  AdaptGradient { istep = 1 } { maxlevel = 8 cmax = 5e-2 } T

  # Writes the time and timestep every 10 timesteps on standard error
  OutputTime { istep = 10 } stderr

  # Writes the simulation size every 10 timesteps on standard error
  OutputBalance { istep = 10 } stderr

  # Writes info about the convergence of the Poisson solver on standard error
  OutputProjectionStats { istep = 10 } stderr

  # Outputs profiling information at the end of the simulation to standard error
  OutputTiming { start = end } stderr

  # Outputs the simulation every 4 timesteps
  OutputSimulation { istep = 4 } stdout { binary = 1 }
 
  # boussinesq.gfv contains the visualisation parameters used by GfsView
  EventScript { start = 0 } { cat boussinesq.gfv }
 
  # Every 4 timesteps, GfsView will read the following command, after having read
  # the simulation file and will output a PPM screenshot on its standard output
  EventScript { istep = 4 } { echo "Save stdout { width = 256 height = 512 }" }
 
  # At the end of the simulation, GfsView will create the EPS file used in the doc.
  EventScript { start = end } { echo "Save t.eps { format = EPS }" }
}
GfsBox {}
# The top boundary is a simple outflow condition. This could cause problems
# (eddies getting stuck on the boundary) if the adaptive "sponge" layer was not
# used.
GfsBox { top = BoundaryOutflow }
1 2 top

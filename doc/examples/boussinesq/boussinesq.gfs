# Title: Boussinesq flow generated by a heated cylinder
#
# Description:
#
# The classical Boussinesq approximation is applied to solve the flow
# generated by a heated cylinder. 
#
# A source term proportional to a diffusive tracer is added to the
# vertical component of the velocity field.
#
# Adaptivity is used to generate a "sponge" outflow condition on the
# top boundary.
#
# The turbulent plume obtained is illustrated on Figure \ref{tracer}.
#
# \begin{figure}[htbp]
# \begin{center}
# \htmladdnormallinkfoot{\includegraphics[width=0.3\hsize]{t.eps}}{t.mpg}
# \end{center}
# \caption{MPEG movie of the tracer field.}
# \label{tracer}
# \end{figure}
#
# Author: St\'ephane Popinet
# Command: gerris2D boussinesq.gfs
# Version: 0.6.4
# Required files: cylinder.gts
# Running time: 60 minutes
# Generated files: t.mpg t.eps
#
2 1 GfsSimulation GfsBox GfsGEdge {} {
  Time { end = 20 }

  # Use an initial refinement of 8 levels around the solid boundary
  RefineSolid 8

  # Insert the solid boundary defined by cylinder.gts
  GtsSurfaceFile cylinder.gts

  # Add a passive tracer called T
  VariableTracer {} T

  # Add diffusion to tracer T
  SourceDiffusion {} T 0.0001
 
  # Add a source term to the vertical velocity component equal to T
  Source {} V T

  # Dirichlet boundary condition for T on the cylinder
  SurfaceBc T Dirichlet 1

  # Adapt the mesh using the vorticity criterion at every timestep
  # down to a maximum level of 8 if y is smaller than 1.25, 3 otherwise.
  # The topmost part of the domain will never have more than
  # 3 levels of refinement and will act as a very efficient "sponge"
  # layer to damp any eddies before they exit the domain.
  AdaptVorticity { istep = 1 } { maxlevel = (y > 1.25 ? 3 : 8) cmax = 1e-2 }

  # Also adapt according to the tracer gradient
  AdaptGradient { istep = 1 } { maxlevel = 8 cmax = 5e-2 } T

  # Writes the time and timestep every 10 timesteps on standard error
  OutputTime { istep = 10 } stderr

  # Writes the simulation size every 10 timesteps on standard error
  OutputBalance { istep = 10 } stderr

  # Writes info about the convergence of the Poisson solver on standard error
  OutputProjectionStats { istep = 10 } stderr

  # Pipes a bitmap PPM image representation of the T field every 4 timestepsq
  # into a MJPEGTools conversion pipeline to create a MPEG movie called t.mpg
  # Sets the minimum used for colormapping to 0 and the maximum to 1
  OutputPPM { istep = 4 } { ppmtoy4m -F 24:1 -v 0 | mpeg2enc -v 0 -o t.mpg } {
    min = 0 max = 1 v = T
  }

  # Pipes a bitmap PPM image representation of the T field at time 15
  # into the ImageMagick converter "convert" to create the corresponding EPS file
  OutputPPM { start = 15 } { convert -colors 256 ppm:- t.eps } {
    min = 0 max = 1 v = T
  }

  # Outputs profiling information at the end of the simulation to standard error
  OutputTiming { start = end } stderr
}
GfsBox {}
# The top boundary is a simple outflow condition. This could cause problems
# (eddies getting stuck on the boundary) if the adaptive "sponge" layer was not
# used.
GfsBox { top = BoundaryOutflow }
1 2 top
